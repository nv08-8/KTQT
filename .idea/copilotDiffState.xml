<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Allow app to access the internet for network requests --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.KTQT&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity android:name=&quot;.ui.auth.LoginActivity&quot; android:exported=&quot;true&quot; /&gt;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterActivity&quot; android:exported=&quot;true&quot; /&gt;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterOtpActivity&quot; android:exported=&quot;true&quot; /&gt;&#10;        &lt;activity android:name=&quot;.ui.intro.IntroActivity&quot; android:exported=&quot;true&quot; /&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- Allow app to access the internet for network requests --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.KTQT&quot;&gt;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.LoginActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterOtpActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.intro.IntroActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/vn/hcmute/ktqt/network/RetrofitClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/vn/hcmute/ktqt/network/RetrofitClient.java" />
              <option name="originalContent" value="//Vo Nguyen Quynh Nhu - 23162074&#10;package vn.hcmute.ktqt.network;&#10;&#10;import android.content.Context;&#10;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.logging.HttpLoggingInterceptor;&#10;import retrofit2.Retrofit;&#10;import retrofit2.converter.gson.GsonConverterFactory;&#10;import vn.hcmute.ktqt.data.SessionManager;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;public class RetrofitClient {&#10;    private static final String BASE_URL = &quot;https://api.utebook.com/&quot;; // TODO: change&#10;    private static Retrofit retrofit;&#10;&#10;    public static Retrofit getClient(Context context) {&#10;        if (retrofit == null) {&#10;            SessionManager session = new SessionManager(context);&#10;&#10;            HttpLoggingInterceptor logging = new HttpLoggingInterceptor();&#10;            logging.setLevel(HttpLoggingInterceptor.Level.BODY);&#10;&#10;            OkHttpClient.Builder httpClient = new OkHttpClient.Builder()&#10;                    .connectTimeout(30, TimeUnit.SECONDS)&#10;                    .readTimeout(30, TimeUnit.SECONDS)&#10;                    .writeTimeout(30, TimeUnit.SECONDS)&#10;                    .addInterceptor(logging);&#10;&#10;            httpClient.addInterceptor(chain -&gt; {&#10;                Request original = chain.request();&#10;                Request.Builder builder = original.newBuilder();&#10;                String token = session.getToken();&#10;                if (token != null &amp;&amp; !token.isEmpty()) {&#10;                    builder.header(&quot;Authorization&quot;, &quot;Bearer &quot; + token);&#10;                }&#10;                Request request = builder.build();&#10;                return chain.proceed(request);&#10;            });&#10;&#10;            retrofit = new Retrofit.Builder()&#10;                    .baseUrl(BASE_URL)&#10;                    .client(httpClient.build())&#10;                    .addConverterFactory(GsonConverterFactory.create())&#10;                    .build();&#10;        }&#10;        return retrofit;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="//Vo Nguyen Quynh Nhu - 23162074&#10;package vn.hcmute.ktqt.network;&#10;&#10;import android.content.Context;&#10;&#10;import okhttp3.OkHttpClient;&#10;import okhttp3.Request;&#10;import okhttp3.logging.HttpLoggingInterceptor;&#10;import retrofit2.Retrofit;&#10;import retrofit2.converter.gson.GsonConverterFactory;&#10;import vn.hcmute.ktqt.data.SessionManager;&#10;&#10;import java.util.concurrent.TimeUnit;&#10;&#10;public class RetrofitClient {&#10;    // Use the emulator loopback address to reach the host machine's backend during development&#10;    private static final String BASE_URL = &quot;http://10.0.2.2:3000/&quot;; // was: &quot;https://api.uteboo.com/&quot; // TODO: use BuildConfig for env-specific URLs&#10;    private static Retrofit retrofit;&#10;&#10;    public static Retrofit getClient(Context context) {&#10;        if (retrofit == null) {&#10;            SessionManager session = new SessionManager(context);&#10;&#10;            HttpLoggingInterceptor logging = new HttpLoggingInterceptor();&#10;            logging.setLevel(HttpLoggingInterceptor.Level.BODY);&#10;&#10;            OkHttpClient.Builder httpClient = new OkHttpClient.Builder()&#10;                    .connectTimeout(30, TimeUnit.SECONDS)&#10;                    .readTimeout(30, TimeUnit.SECONDS)&#10;                    .writeTimeout(30, TimeUnit.SECONDS)&#10;                    .addInterceptor(logging);&#10;&#10;            httpClient.addInterceptor(chain -&gt; {&#10;                Request original = chain.request();&#10;                Request.Builder builder = original.newBuilder();&#10;                String token = session.getToken();&#10;                if (token != null &amp;&amp; !token.isEmpty()) {&#10;                    builder.header(&quot;Authorization&quot;, &quot;Bearer &quot; + token);&#10;                }&#10;                Request request = builder.build();&#10;                return chain.proceed(request);&#10;            });&#10;&#10;            retrofit = new Retrofit.Builder()&#10;                    .baseUrl(BASE_URL)&#10;                    .client(httpClient.build())&#10;                    .addConverterFactory(GsonConverterFactory.create())&#10;                    .build();&#10;        }&#10;        return retrofit;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend_api/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend_api/server.js" />
              <option name="originalContent" value="const express = require(&quot;express&quot;);&#10;const connectDB = require(&quot;./db&quot;);&#10;const Book = require(&quot;./models/Book&quot;);&#10;const User = require(&quot;./models/User&quot;);&#10;const bcrypt = require(&quot;bcryptjs&quot;);&#10;const jwt = require(&quot;jsonwebtoken&quot;);&#10;&#10;const app = express();&#10;app.use(express.json());&#10;&#10;// Connect to MongoDB&#10;connectDB();&#10;&#10;// Test add data&#10;app.get(&quot;/test&quot;, async (req, res) =&gt; {&#10;  try {&#10;    const book = await Book.create({&#10;      title: &quot;UTEBook&quot;,&#10;      price: 99&#10;    });&#10;    res.json(book);&#10;  } catch (error) {&#10;    console.error(&quot;/test error:&quot;, error);&#10;    res.status(500).json({ error: error.message });&#10;  }&#10;});&#10;&#10;// Register endpoint&#10;app.post('/api/register', async (req, res) =&gt; {&#10;  try {&#10;    const { name, email, password, phone } = req.body;&#10;    if (!name || !email || !password) return res.status(400).json({ message: 'Missing required fields' });&#10;&#10;    const existing = await User.findOne({ email });&#10;    if (existing) return res.status(400).json({ message: 'Email already registered' });&#10;&#10;    const hashed = await bcrypt.hash(password, 10);&#10;    // generate a simple numeric id (auto-increment-like)&#10;    const last = await User.findOne().sort({ id: -1 }).select('id');&#10;    const nextId = last &amp;&amp; last.id ? last.id + 1 : 1;&#10;&#10;    const user = await User.create({&#10;      id: nextId,&#10;      name,&#10;      email,&#10;      password: hashed,&#10;      phone,&#10;      status: 'inactive',&#10;      otp_code: Math.floor(100000 + Math.random() * 900000)&#10;    });&#10;&#10;    // In a real app you'd send the OTP via SMS/Email. For now return it in response (or remove in prod)&#10;    res.status(201).json({ message: 'User registered', userId: user.id, otp_code: user.otp_code });&#10;  } catch (error) {&#10;    console.error('/api/register error:', error);&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;});&#10;&#10;// Login endpoint&#10;app.post('/api/login', async (req, res) =&gt; {&#10;  try {&#10;    const { email, password } = req.body;&#10;    if (!email || !password) return res.status(400).json({ message: 'Missing email or password' });&#10;&#10;    const user = await User.findOne({ email });&#10;    if (!user) return res.status(401).json({ message: 'Invalid credentials' });&#10;&#10;    const ok = await bcrypt.compare(password, user.password);&#10;    if (!ok) return res.status(401).json({ message: 'Invalid credentials' });&#10;&#10;    // create JWT&#10;    const token = jwt.sign({ id: user.id, email: user.email, role: user.role }, process.env.JWT_SECRET || 'secretkey', { expiresIn: '7d' });&#10;&#10;    res.json({ message: 'Login successful', token, user: { id: user.id, name: user.name, email: user.email, phone: user.phone, role: user.role } });&#10;  } catch (error) {&#10;    console.error('/api/login error:', error);&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;});&#10;&#10;const PORT = process.env.PORT || 3000;&#10;app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));&#10;" />
              <option name="updatedContent" value="const express = require(&quot;express&quot;);&#13;&#10;const connectDB = require(&quot;./db&quot;);&#13;&#10;const Book = require(&quot;./models/Book&quot;);&#13;&#10;const User = require(&quot;./models/User&quot;);&#13;&#10;const bcrypt = require(&quot;bcryptjs&quot;);&#13;&#10;const jwt = require(&quot;jsonwebtoken&quot;);&#13;&#10;&#13;&#10;const app = express();&#13;&#10;app.use(express.json());&#13;&#10;&#13;&#10;// Connect to MongoDB&#13;&#10;connectDB();&#13;&#10;&#13;&#10;// Test add data&#13;&#10;app.get(&quot;/test&quot;, async (req, res) =&gt; {&#13;&#10;  try {&#13;&#10;    const book = await Book.create({&#13;&#10;      title: &quot;UTEBook&quot;,&#13;&#10;      price: 99&#13;&#10;    });&#13;&#10;    res.json(book);&#13;&#10;  } catch (error) {&#13;&#10;    console.error(&quot;/test error:&quot;, error);&#13;&#10;    res.status(500).json({ error: error.message });&#13;&#10;  }&#13;&#10;});&#13;&#10;&#13;&#10;// Extract handlers so we can mount them under multiple routes (/api/* and /auth/*)&#13;&#10;const registerHandler = async (req, res) =&gt; {&#13;&#10;  try {&#13;&#10;    const { name, email, password, phone } = req.body;&#13;&#10;    if (!name || !email || !password) return res.status(400).json({ message: 'Missing required fields' });&#13;&#10;&#13;&#10;    const existing = await User.findOne({ email });&#13;&#10;    if (existing) return res.status(400).json({ message: 'Email already registered' });&#13;&#10;&#13;&#10;    const hashed = await bcrypt.hash(password, 10);&#13;&#10;    // generate a simple numeric id (auto-increment-like)&#13;&#10;    const last = await User.findOne().sort({ id: -1 }).select('id');&#13;&#10;    const nextId = last &amp;&amp; last.id ? last.id + 1 : 1;&#13;&#10;&#13;&#10;    const user = await User.create({&#13;&#10;      id: nextId,&#13;&#10;      name,&#13;&#10;      email,&#13;&#10;      password: hashed,&#13;&#10;      phone,&#13;&#10;      status: 'inactive',&#13;&#10;      otp_code: Math.floor(100000 + Math.random() * 900000)&#13;&#10;    });&#13;&#10;&#13;&#10;    // In a real app you'd send the OTP via SMS/Email. For now return it in response (or remove in prod)&#13;&#10;    res.status(201).json({ message: 'User registered', userId: user.id, otp_code: user.otp_code });&#13;&#10;  } catch (error) {&#13;&#10;    console.error('/api/register error:', error);&#13;&#10;    res.status(500).json({ message: error.message });&#13;&#10;  }&#13;&#10;};&#13;&#10;&#13;&#10;const loginHandler = async (req, res) =&gt; {&#13;&#10;  try {&#13;&#10;    const { email, password } = req.body;&#13;&#10;    if (!email || !password) return res.status(400).json({ message: 'Missing email or password' });&#13;&#10;&#13;&#10;    const user = await User.findOne({ email });&#13;&#10;    if (!user) return res.status(401).json({ message: 'Invalid credentials' });&#13;&#10;&#13;&#10;    const ok = await bcrypt.compare(password, user.password);&#13;&#10;    if (!ok) return res.status(401).json({ message: 'Invalid credentials' });&#13;&#10;&#13;&#10;    // create JWT&#13;&#10;    const token = jwt.sign({ id: user.id, email: user.email, role: user.role }, process.env.JWT_SECRET || 'secretkey', { expiresIn: '7d' });&#13;&#10;&#13;&#10;    res.json({ message: 'Login successful', token, user: { id: user.id, name: user.name, email: user.email, phone: user.phone, role: user.role } });&#13;&#10;  } catch (error) {&#13;&#10;    console.error('/api/login error:', error);&#13;&#10;    res.status(500).json({ message: error.message });&#13;&#10;  }&#13;&#10;};&#13;&#10;&#13;&#10;// Register endpoints (mounted under both /api and /auth for compatibility with the Android app)&#13;&#10;app.post('/api/register', registerHandler);&#13;&#10;app.post('/auth/register', registerHandler);&#13;&#10;&#13;&#10;// Login endpoints&#13;&#10;app.post('/api/login', loginHandler);&#13;&#10;app.post('/auth/login', loginHandler);&#13;&#10;&#13;&#10;const PORT = process.env.PORT || 3000;&#13;&#10;app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db.js" />
              <option name="updatedContent" value="const mongoose = require(&quot;mongoose&quot;);&#10;&#10;async function connectDB() {&#10;  try {&#10;    await mongoose.connect(&#10;      &quot;mongodb+srv://admin:4kTVlrRaaTthqvgW@bookstore.5ku2c2q.mongodb.net/bookstore?retryWrites=true&amp;w=majority&quot;,&#10;      {&#10;        useNewUrlParser: true,&#10;        useUnifiedTopology: true,&#10;      }&#10;    );&#10;&#10;    console.log(&quot;MongoDB connected!&quot;);&#10;  } catch (error) {&#10;    console.error(&quot;MongoDB connection error:&quot;, error);&#10;  }&#10;}&#10;&#10;module.exports = connectDB;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/models/Book.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/models/Book.js" />
              <option name="updatedContent" value="const mongoose = require(&quot;mongoose&quot;);&#10;&#10;const bookSchema = new mongoose.Schema({&#10;  title: String,&#10;  price: Number,&#10;});&#10;&#10;module.exports = mongoose.model(&quot;Book&quot;, bookSchema);&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;ktqt-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Minimal Node.js server for the KTQT book app&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;express&quot;: &quot;^4.18.2&quot;,&#10;    &quot;mongoose&quot;: &quot;^7.6.1&quot;&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server.js" />
              <option name="updatedContent" value="const express = require(&quot;express&quot;);&#10;const connectDB = require(&quot;./db&quot;);&#10;const Book = require(&quot;./models/Book&quot;);&#10;&#10;const app = express();&#10;app.use(express.json());&#10;&#10;// Connect to MongoDB&#10;connectDB();&#10;&#10;// Test add data&#10;app.get(&quot;/test&quot;, async (req, res) =&gt; {&#10;  try {&#10;    const book = await Book.create({&#10;      title: &quot;Sách MongoDB của bé iu&quot;,&#10;      price: 99&#10;    });&#10;    res.json(book);&#10;  } catch (error) {&#10;    console.error(&quot;/test error:&quot;, error);&#10;    res.status(500).json({ error: error.message });&#10;  }&#10;});&#10;&#10;const PORT = process.env.PORT || 3000;&#10;app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>