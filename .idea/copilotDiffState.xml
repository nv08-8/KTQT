<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Allow app to access the internet for network requests --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.KTQT&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot; /&gt;&#10;&#10;        &lt;activity android:name=&quot;.ui.auth.LoginActivity&quot; android:exported=&quot;true&quot; /&gt;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterActivity&quot; android:exported=&quot;true&quot; /&gt;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterOtpActivity&quot; android:exported=&quot;true&quot; /&gt;&#10;        &lt;activity android:name=&quot;.ui.intro.IntroActivity&quot; android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- Allow app to access the internet for network requests --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:usesCleartextTraffic=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.KTQT&quot;&gt;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.LoginActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.RegisterOtpActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.OtpVerificationActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.auth.ResetPasswordActivity&quot; android:exported=&quot;true&quot; /&gt;&#13;&#10;        &lt;activity android:name=&quot;.ui.intro.IntroActivity&quot; android:exported=&quot;true&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/vn/hcmute/ktqt/api/ApiClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/vn/hcmute/ktqt/api/ApiClient.java" />
              <option name="originalContent" value="package vn.hcmute.ktqt.api;&#10;&#10;import retrofit2.Retrofit;&#10;import retrofit2.converter.gson.GsonConverterFactory;&#10;&#10;public class ApiClient {&#10;    private static final String BASE_URL = &quot;https://10.0.2.2:3000/&quot;; // &lt;-- IMPORTANT: REPLACE WITH YOUR API's BASE URL&#10;&#10;    private static Retrofit retrofit = null;&#10;&#10;    public static Retrofit getClient() {&#10;        if (retrofit == null) {&#10;            retrofit = new Retrofit.Builder()&#10;                    .baseUrl(BASE_URL)&#10;                    .addConverterFactory(GsonConverterFactory.create())&#10;                    .build();&#10;        }&#10;        return retrofit;&#10;    }&#10;}" />
              <option name="updatedContent" value="package vn.hcmute.ktqt.api;&#10;&#10;import retrofit2.Retrofit;&#10;import retrofit2.converter.gson.GsonConverterFactory;&#10;&#10;public class ApiClient {&#10;    private static final String BASE_URL = &quot;https://10.0.2.2:3000/&quot;; // &lt;-- IMPORTANT: REPLACE WITH YOUR API's BASE URL&#10;&#10;    private static Retrofit retrofit = null;&#10;&#10;    public static Retrofit getClient() {&#10;        if (retrofit == null) {&#10;            retrofit = new Retrofit.Builder()&#10;                    .baseUrl(BASE_URL)&#10;                    .addConverterFactory(GsonConverterFactory.create())&#10;                    .build();&#10;        }&#10;        return retrofit;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend_api/routes/authRoutes.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend_api/routes/authRoutes.js" />
              <option name="originalContent" value="const express = require(&quot;express&quot;);&#10;const router = express.Router();&#10;const User = require(&quot;../models/User&quot;);&#10;const bcrypt = require(&quot;bcryptjs&quot;);&#10;const sendOtp = require(&quot;../utils/sendOtp&quot;);&#10;const SALT_ROUNDS = 10;&#10;const jwt = require('jsonwebtoken');&#10;const JWT_SECRET = process.env.JWT_SECRET || 'dev_jwt_secret_change_me';&#10;&#10;router.post(&quot;/send-otp&quot;, async (req, res) =&gt; {&#10;    const { email } = req.body;&#10;&#10;    if (!email)&#10;        return res.status(400).json({ message: &quot;Thiếu email!&quot; });&#10;&#10;    const otp = Math.floor(100000 + Math.random() * 900000);&#10;&#10;    try {&#10;        let user = await User.findOne({ email });&#10;&#10;        let createdNewUser = false;&#10;        if (!user) {&#10;            user = new User({&#10;                email,&#10;                name: email.split('@')[0], // Use part of email as a temporary name&#10;                password: 'temp_password_please_change', // Temporary password&#10;                otp_code: otp,&#10;                status: 'inactive'&#10;            });&#10;            await user.save();&#10;            createdNewUser = true;&#10;        } else {&#10;            if (user.status === &quot;active&quot;) {&#10;                return res.status(400).json({ message: &quot;Email đã tồn tại!&quot; });&#10;            }&#10;            user.otp_code = otp;&#10;            await user.save();&#10;        }&#10;&#10;        // Attempt to send email and wait for result; if it fails, rollback the created user or clear otp&#10;        try {&#10;            await sendOtp(email, &quot;Mã OTP đăng ký&quot;, `Mã OTP của bạn là: ${otp}`);&#10;            return res.json({ message: &quot;OTP đã được gửi đến email!&quot; });&#10;        } catch (emailErr) {&#10;            console.error(&quot;Gửi email thất bại:&quot;, emailErr);&#10;            // Rollback: if we created a new user, remove it to avoid stale inactive users&#10;            if (createdNewUser) {&#10;                try { await User.deleteOne({ _id: user._id }); } catch (delErr) { console.error('Rollback delete failed:', delErr); }&#10;            } else {&#10;                // Clear the otp_code if it was updated&#10;                try { user.otp_code = null; await user.save(); } catch (clearErr) { console.error('Clearing OTP failed:', clearErr); }&#10;            }&#10;&#10;            // If the error message indicates missing SendGrid config, return 500 with a helpful message&#10;            if (emailErr.message &amp;&amp; emailErr.message.includes('SENDGRID_API_KEY')) {&#10;                return res.status(500).json({ message: 'Server email configuration error. Please contact the administrator.' });&#10;            }&#10;&#10;            // Map SendGrid 401/Unauthorized to 502 Bad Gateway to indicate third-party failure&#10;            const statusCode = emailErr.code || emailErr.statusCode || emailErr.response?.status || emailErr.response?.statusCode;&#10;            if (statusCode === 401) {&#10;                console.error('SendGrid returned 401 Unauthorized');&#10;                return res.status(502).json({ message: 'Gửi email thất bại: Unauthorized with SendGrid.' });&#10;            }&#10;&#10;            return res.status(502).json({ message: 'Gửi email thất bại. Vui lòng thử lại sau.' });&#10;        }&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi gửi OTP:&quot;, err);&#10;        res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/verify-otp&quot;, async (req, res) =&gt; {&#10;    const { email, otp } = req.body;&#10;    try {&#10;        const user = await User.findOne({ email, otp_code: otp });&#10;        if (!user) {&#10;            return res.status(400).json({ success: false, message: &quot;OTP sai!&quot; });&#10;        }&#10;        return res.json({ success: true, message: &quot;OTP hợp lệ!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi verify OTP:&quot;, err);&#10;        return res.status(500).json({ success: false, message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/finish-register&quot;, async (req, res) =&gt; {&#10;    const { name, phone, email, password } = req.body;&#10;    if (!name || !phone || !email || !password)&#10;        return res.status(400).json({ message: &quot;Thiếu thông tin!&quot; });&#10;&#10;    const phoneStr = phone.toString().trim();&#10;    if (!/^\d{9,11}$/.test(phoneStr)) {&#10;        return res.status(400).json({ message: &quot;Số điện thoại không hợp lệ.&quot; });&#10;    }&#10;&#10;    try {&#10;        const existingPhone = await User.findOne({ phone: phoneStr, status: 'active' });&#10;        if (existingPhone) {&#10;            return res.status(400).json({ message: &quot;Số điện thoại đã được sử dụng!&quot; });&#10;        }&#10;&#10;        const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);&#10;        &#10;        const updatedUser = await User.findOneAndUpdate(&#10;            { email, status: 'inactive' },&#10;            {&#10;                name,&#10;                phone: phoneStr,&#10;                password: hashedPassword,&#10;                otp_code: null,&#10;                status: 'active'&#10;            },&#10;            { new: true }&#10;        );&#10;&#10;        if (!updatedUser) {&#10;            return res.status(404).json({ message: &quot;Không tìm thấy tài khoản hoặc tài khoản đã được kích hoạt.&quot; });&#10;        }&#10;&#10;        return res.json({ message: &quot;Tạo tài khoản thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi tạo tài khoản:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/login&quot;, async (req, res) =&gt; {&#10;    const { email, password } = req.body;&#10;    try {&#10;        const user = await User.findOne({ email }).select('+password');;&#10;        if (!user) {&#10;            return res.status(401).json({ message: &quot;Sai email hoặc mật khẩu!&quot; });&#10;        }&#10;&#10;        if (user.status !== &quot;active&quot;) {&#10;            return res.status(403).json({ message: &quot;Tài khoản chưa xác thực email!&quot; });&#10;        }&#10;&#10;        const isMatch = await bcrypt.compare(password, user.password);&#10;        if (!isMatch) {&#10;            return res.status(401).json({ message: &quot;Sai email hoặc mật khẩu!&quot; });&#10;        }&#10;&#10;        const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: '7d' });&#10;&#10;        return res.json({&#10;            message: &quot;Đăng nhập thành công!&quot;,&#10;            user: user.toJSON(),&#10;            token&#10;        });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi đăng nhập:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/forgot-password&quot;, async (req, res) =&gt; {&#10;    const { email } = req.body;&#10;    const otp = Math.floor(100000 + Math.random() * 900000);&#10;    try {&#10;        const user = await User.findOneAndUpdate(&#10;            { email, status: 'active' },&#10;            { otp_code: otp },&#10;            { new: true }&#10;        );&#10;&#10;        if (!user) {&#10;            return res.status(404).json({ message: &quot;Email không tồn tại hoặc chưa active!&quot; });&#10;        }&#10;&#10;        res.json({ success: true, message: &quot;OTP đã được gửi đến email!&quot; });&#10;        sendOtp(email, &quot;Mã OTP đặt lại mật khẩu&quot;, `Mã OTP của bạn là: ${otp}`)&#10;            .catch(emailErr =&gt; console.error(&quot;Gửi email quên mật khẩu thất bại:&quot;, emailErr));&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi forgot password:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/reset-password&quot;, async (req, res) =&gt; {&#10;    // Make sure client sends email, otp, and newPassword&#10;    const { email, otp, newPassword } = req.body;&#10;    if (!email || !otp || !newPassword) {&#10;        return res.status(400).json({ message: &quot;Thiếu thông tin!&quot; });&#10;    }&#10;&#10;    try {&#10;        const hashedPassword = await bcrypt.hash(newPassword, SALT_ROUNDS);&#10;        const user = await User.findOneAndUpdate(&#10;            { email, otp_code: otp, status: 'active' },&#10;            { password: hashedPassword, otp_code: null },&#10;            { new: true }&#10;        );&#10;&#10;        if (!user) {&#10;            return res.status(400).json({ message: &quot;OTP không hợp lệ hoặc email không tồn tại.&quot; });&#10;        }&#10;        res.json({ success: true, message: &quot;Đặt lại mật khẩu thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi reset mật khẩu:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.get(&quot;/user/:id&quot;, async (req, res) =&gt; {&#10;    const { id } = req.params;&#10;    try {&#10;        const user = await User.findById(id);&#10;        if (!user || user.status !== 'active') {&#10;            return res.status(404).json({ message: &quot;User not found&quot; });&#10;        }&#10;        res.json(user);&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi lấy user:&quot;, err);&#10;        if (err.name === 'CastError') {&#10;            return res.status(400).json({ message: &quot;Invalid user ID format&quot; });&#10;        }&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/change-password&quot;, async (req, res) =&gt; {&#10;    const { email, currentPassword, newPassword } = req.body;&#10;    if (!email || !currentPassword || !newPassword) {&#10;        return res.status(400).json({ success: false, message: &quot;Thiếu thông tin!&quot; });&#10;    }&#10;&#10;    try {&#10;        const user = await User.findOne({ email, status: 'active' }).select('+password');&#10;        if (!user) {&#10;            return res.status(404).json({ success: false, message: &quot;User not found&quot; });&#10;        }&#10;&#10;        const isMatch = await bcrypt.compare(currentPassword, user.password);&#10;        if (!isMatch) {&#10;            return res.status(401).json({ success: false, message: &quot;Mật khẩu hiện tại không đúng!&quot; });&#10;        }&#10;&#10;        user.password = await bcrypt.hash(newPassword, SALT_ROUNDS);&#10;        await user.save();&#10;        res.json({ success: true, message: &quot;Đổi mật khẩu thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi đổi mật khẩu:&quot;, err);&#10;        return res.status(500).json({ success: false, message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.put(&quot;/user/:id&quot;, async (req, res) =&gt; {&#10;    const { id } = req.params;&#10;    const { name, phone } = req.body;&#10;    if (!name &amp;&amp; !phone) {&#10;        return res.status(400).json({ success: false, message: &quot;Không có thông tin để cập nhật!&quot; });&#10;    }&#10;&#10;    try {&#10;        const updateData = {};&#10;        if (name) updateData.name = name;&#10;        if (phone) {&#10;             const phoneStr = phone.toString().trim();&#10;            if (!/^\d{9,11}$/.test(phoneStr)) {&#10;                return res.status(400).json({ success: false, message: &quot;Số điện thoại không hợp lệ.&quot; });&#10;            }&#10;            const existingPhoneUser = await User.findOne({ phone: phoneStr, _id: { $ne: id } });&#10;            if (existingPhoneUser) {&#10;                return res.status(400).json({ success: false, message: &quot;Số điện thoại đã được sử dụng!&quot; });&#10;            }&#10;            updateData.phone = phoneStr;&#10;        }&#10;&#10;        const updatedUser = await User.findByIdAndUpdate(&#10;            id,&#10;            { $set: updateData },&#10;            { new: true }&#10;        );&#10;&#10;        if (!updatedUser) {&#10;            return res.status(404).json({ success: false, message: &quot;User not found&quot; });&#10;        }&#10;        res.json({ success: true, message: &quot;Cập nhật thông tin thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi cập nhật user:&quot;, err);&#10;        if (err.name === 'CastError') {&#10;            return res.status(400).json({ message: &quot;Invalid user ID format&quot; });&#10;        }&#10;        return res.status(500).json({ success: false, message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;module.exports = router;&#10;" />
              <option name="updatedContent" value="const express = require(&quot;express&quot;);&#10;const router = express.Router();&#10;const User = require(&quot;../models/User&quot;);&#10;const bcrypt = require(&quot;bcryptjs&quot;);&#10;const sendOtp = require(&quot;../utils/sendOtp&quot;);&#10;const SALT_ROUNDS = 10;&#10;const jwt = require('jsonwebtoken');&#10;const JWT_SECRET = process.env.JWT_SECRET || 'dev_jwt_secret_change_me';&#10;&#10;router.post(&quot;/send-otp&quot;, async (req, res) =&gt; {&#10;    const { email } = req.body;&#10;&#10;    if (!email)&#10;        return res.status(400).json({ message: &quot;Thiếu email!&quot; });&#10;&#10;    const otp = Math.floor(100000 + Math.random() * 900000);&#10;&#10;    try {&#10;        let user = await User.findOne({ email });&#10;&#10;        let createdNewUser = false;&#10;        if (!user) {&#10;            user = new User({&#10;                email,&#10;                name: email.split('@')[0], // Use part of email as a temporary name&#10;                password: 'temp_password_please_change', // Temporary password&#10;                otp_code: otp,&#10;                status: 'inactive'&#10;            });&#10;            await user.save();&#10;            createdNewUser = true;&#10;        } else {&#10;            if (user.status === &quot;active&quot;) {&#10;                return res.status(400).json({ message: &quot;Email đã tồn tại!&quot; });&#10;            }&#10;            user.otp_code = otp;&#10;            await user.save();&#10;        }&#10;&#10;        // Attempt to send email and wait for result; if it fails, rollback the created user or clear otp&#10;        try {&#10;            await sendOtp(email, &quot;Mã OTP đăng ký&quot;, `Mã OTP của bạn là: ${otp}`);&#10;            return res.json({ message: &quot;OTP đã được gửi đến email!&quot; });&#10;        } catch (emailErr) {&#10;            console.error(&quot;Gửi email thất bại:&quot;, emailErr);&#10;            // Rollback: if we created a new user, remove it to avoid stale inactive users&#10;            if (createdNewUser) {&#10;                try { await User.deleteOne({ _id: user._id }); } catch (delErr) { console.error('Rollback delete failed:', delErr); }&#10;            } else {&#10;                // Clear the otp_code if it was updated&#10;                try { user.otp_code = null; await user.save(); } catch (clearErr) { console.error('Clearing OTP failed:', clearErr); }&#10;            }&#10;&#10;            // If the error message indicates missing SendGrid config, return 500 with a helpful message&#10;            if (emailErr.message &amp;&amp; emailErr.message.includes('SENDGRID_API_KEY')) {&#10;                return res.status(500).json({ message: 'Server email configuration error. Please contact the administrator.' });&#10;            }&#10;&#10;            // Map SendGrid 401/Unauthorized to 502 Bad Gateway to indicate third-party failure&#10;            const statusCode = emailErr.code || emailErr.statusCode || emailErr.response?.status || emailErr.response?.statusCode;&#10;            if (statusCode === 401) {&#10;                console.error('SendGrid returned 401 Unauthorized');&#10;                return res.status(502).json({ message: 'Gửi email thất bại: Unauthorized with SendGrid.' });&#10;            }&#10;&#10;            return res.status(502).json({ message: 'Gửi email thất bại. Vui lòng thử lại sau.' });&#10;        }&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi gửi OTP:&quot;, err);&#10;        res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/verify-otp&quot;, async (req, res) =&gt; {&#10;    const { email, otp } = req.body;&#10;    try {&#10;        const user = await User.findOne({ email, otp_code: otp });&#10;        if (!user) {&#10;            return res.status(400).json({ success: false, message: &quot;OTP sai!&quot; });&#10;        }&#10;        return res.json({ success: true, message: &quot;OTP hợp lệ!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi verify OTP:&quot;, err);&#10;        return res.status(500).json({ success: false, message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/finish-register&quot;, async (req, res) =&gt; {&#10;    const { name, phone, email, password } = req.body;&#10;    if (!name || !phone || !email || !password)&#10;        return res.status(400).json({ message: &quot;Thiếu thông tin!&quot; });&#10;&#10;    const phoneStr = phone.toString().trim();&#10;    if (!/^\d{9,11}$/.test(phoneStr)) {&#10;        return res.status(400).json({ message: &quot;Số điện thoại không hợp lệ.&quot; });&#10;    }&#10;&#10;    try {&#10;        const existingPhone = await User.findOne({ phone: phoneStr, status: 'active' });&#10;        if (existingPhone) {&#10;            return res.status(400).json({ message: &quot;Số điện thoại đã được sử dụng!&quot; });&#10;        }&#10;&#10;        const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);&#10;        &#10;        const updatedUser = await User.findOneAndUpdate(&#10;            { email, status: 'inactive' },&#10;            {&#10;                name,&#10;                phone: phoneStr,&#10;                password: hashedPassword,&#10;                otp_code: null,&#10;                status: 'active'&#10;            },&#10;            { new: true }&#10;        );&#10;&#10;        if (!updatedUser) {&#10;            return res.status(404).json({ message: &quot;Không tìm thấy tài khoản hoặc tài khoản đã được kích hoạt.&quot; });&#10;        }&#10;&#10;        return res.json({ message: &quot;Tạo tài khoản thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi tạo tài khoản:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/login&quot;, async (req, res) =&gt; {&#10;    const { email, password } = req.body;&#10;    try {&#10;        const user = await User.findOne({ email }).select('+password');;&#10;        if (!user) {&#10;            return res.status(401).json({ message: &quot;Sai email hoặc mật khẩu!&quot; });&#10;        }&#10;&#10;        if (user.status !== &quot;active&quot;) {&#10;            return res.status(403).json({ message: &quot;Tài khoản chưa xác thực email!&quot; });&#10;        }&#10;&#10;        const isMatch = await bcrypt.compare(password, user.password);&#10;        if (!isMatch) {&#10;            return res.status(401).json({ message: &quot;Sai email hoặc mật khẩu!&quot; });&#10;        }&#10;&#10;        const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: '7d' });&#10;&#10;        return res.json({&#10;            message: &quot;Đăng nhập thành công!&quot;,&#10;            user: user.toJSON(),&#10;            token&#10;        });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi đăng nhập:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/forgot-password&quot;, async (req, res) =&gt; {&#10;    const { email } = req.body;&#10;    const otp = Math.floor(100000 + Math.random() * 900000);&#10;    try {&#10;        const user = await User.findOneAndUpdate(&#10;            { email, status: 'active' },&#10;            { otp_code: otp },&#10;            { new: true }&#10;        );&#10;&#10;        if (!user) {&#10;            return res.status(404).json({ message: &quot;Email không tồn tại hoặc chưa active!&quot; });&#10;        }&#10;&#10;        try {&#10;            await sendOtp(email, &quot;Mã OTP đặt lại mật khẩu&quot;, `Mã OTP của bạn là: ${otp}`);&#10;            return res.json({ success: true, message: &quot;OTP đã được gửi đến email!&quot; });&#10;        } catch (emailErr) {&#10;            console.error('Gửi email quên mật khẩu thất bại:', emailErr);&#10;            // Clear otp_code since email failed&#10;            try { user.otp_code = null; await user.save(); } catch (clearErr) { console.error('Clearing OTP failed:', clearErr); }&#10;&#10;            if (emailErr.message &amp;&amp; emailErr.message.includes('SENDGRID_API_KEY')) {&#10;                return res.status(500).json({ message: 'Server email configuration error. Please contact the administrator.' });&#10;            }&#10;&#10;            const statusCode = emailErr.code || emailErr.statusCode || emailErr.response?.status || emailErr.response?.statusCode;&#10;            if (statusCode === 401) {&#10;                console.error('SendGrid returned 401 Unauthorized');&#10;                return res.status(502).json({ message: 'Gửi email thất bại: Unauthorized with SendGrid.' });&#10;            }&#10;&#10;            return res.status(502).json({ message: 'Gửi email thất bại. Vui lòng thử lại sau.' });&#10;        }&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi forgot password:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/reset-password&quot;, async (req, res) =&gt; {&#10;    // Make sure client sends email, otp, and newPassword&#10;    const { email, otp, newPassword } = req.body;&#10;    if (!email || !otp || !newPassword) {&#10;        return res.status(400).json({ message: &quot;Thiếu thông tin!&quot; });&#10;    }&#10;&#10;    try {&#10;        const hashedPassword = await bcrypt.hash(newPassword, SALT_ROUNDS);&#10;        const user = await User.findOneAndUpdate(&#10;            { email, otp_code: otp, status: 'active' },&#10;            { password: hashedPassword, otp_code: null },&#10;            { new: true }&#10;        );&#10;&#10;        if (!user) {&#10;            return res.status(400).json({ message: &quot;OTP không hợp lệ hoặc email không tồn tại.&quot; });&#10;        }&#10;        res.json({ success: true, message: &quot;Đặt lại mật khẩu thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi reset mật khẩu:&quot;, err);&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.get(&quot;/user/:id&quot;, async (req, res) =&gt; {&#10;    const { id } = req.params;&#10;    try {&#10;        const user = await User.findById(id);&#10;        if (!user || user.status !== 'active') {&#10;            return res.status(404).json({ message: &quot;User not found&quot; });&#10;        }&#10;        res.json(user);&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi lấy user:&quot;, err);&#10;        if (err.name === 'CastError') {&#10;            return res.status(400).json({ message: &quot;Invalid user ID format&quot; });&#10;        }&#10;        return res.status(500).json({ message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.post(&quot;/change-password&quot;, async (req, res) =&gt; {&#10;    const { email, currentPassword, newPassword } = req.body;&#10;    if (!email || !currentPassword || !newPassword) {&#10;        return res.status(400).json({ success: false, message: &quot;Thiếu thông tin!&quot; });&#10;    }&#10;&#10;    try {&#10;        const user = await User.findOne({ email, status: 'active' }).select('+password');&#10;        if (!user) {&#10;            return res.status(404).json({ success: false, message: &quot;User not found&quot; });&#10;        }&#10;&#10;        const isMatch = await bcrypt.compare(currentPassword, user.password);&#10;        if (!isMatch) {&#10;            return res.status(401).json({ success: false, message: &quot;Mật khẩu hiện tại không đúng!&quot; });&#10;        }&#10;&#10;        user.password = await bcrypt.hash(newPassword, SALT_ROUNDS);&#10;        await user.save();&#10;        res.json({ success: true, message: &quot;Đổi mật khẩu thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi đổi mật khẩu:&quot;, err);&#10;        return res.status(500).json({ success: false, message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;router.put(&quot;/user/:id&quot;, async (req, res) =&gt; {&#10;    const { id } = req.params;&#10;    const { name, phone } = req.body;&#10;    if (!name &amp;&amp; !phone) {&#10;        return res.status(400).json({ success: false, message: &quot;Không có thông tin để cập nhật!&quot; });&#10;    }&#10;&#10;    try {&#10;        const updateData = {};&#10;        if (name) updateData.name = name;&#10;        if (phone) {&#10;             const phoneStr = phone.toString().trim();&#10;            if (!/^\d{9,11}$/.test(phoneStr)) {&#10;                return res.status(400).json({ success: false, message: &quot;Số điện thoại không hợp lệ.&quot; });&#10;            }&#10;            const existingPhoneUser = await User.findOne({ phone: phoneStr, _id: { $ne: id } });&#10;            if (existingPhoneUser) {&#10;                return res.status(400).json({ success: false, message: &quot;Số điện thoại đã được sử dụng!&quot; });&#10;            }&#10;            updateData.phone = phoneStr;&#10;        }&#10;&#10;        const updatedUser = await User.findByIdAndUpdate(&#10;            id,&#10;            { $set: updateData },&#10;            { new: true }&#10;        );&#10;&#10;        if (!updatedUser) {&#10;            return res.status(404).json({ success: false, message: &quot;User not found&quot; });&#10;        }&#10;        res.json({ success: true, message: &quot;Cập nhật thông tin thành công!&quot; });&#10;    } catch (err) {&#10;        console.error(&quot;Lỗi cập nhật user:&quot;, err);&#10;        if (err.name === 'CastError') {&#10;            return res.status(400).json({ message: &quot;Invalid user ID format&quot; });&#10;        }&#10;        return res.status(500).json({ success: false, message: &quot;Lỗi phía server.&quot; });&#10;    }&#10;});&#10;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend_api/test_sendgrid.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend_api/test_sendgrid.js" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="// Simple SendGrid test script for local debugging&#10;// Usage (PowerShell):&#10;//  node .\test_sendgrid.js&#10;&#10;// Load .env so the script can pick up SENDGRID_API_KEY and SENDGRID_FROM automatically&#10;require('dotenv').config();&#10;&#10;const sg = require('@sendgrid/mail');&#10;&#10;const key = process.env.SENDGRID_API_KEY;&#10;const from = process.env.SENDGRID_FROM;&#10;&#10;if (!key) {&#10;  console.error('SENDGRID_API_KEY is not set. Export it and re-run the script.');&#10;  process.exitCode = 2;&#10;} else if (!from) {&#10;  console.error('SENDGRID_FROM is not set. Export it and re-run the script.');&#10;  process.exitCode = 2;&#10;} else {&#10;  sg.setApiKey(key);&#10;  (async () =&gt; {&#10;    try {&#10;      const res = await sg.send({&#10;        to: from, // send to the same address for quick verification&#10;        from: { email: from, name: 'UTEBook Test' },&#10;        subject: 'SendGrid connectivity test',&#10;        text: 'This is a test message to verify SendGrid API key and sender configuration.'&#10;      });&#10;      console.log('SendGrid response status:', res[0]?.statusCode || 'unknown');&#10;      console.dir(res[0]);&#10;    } catch (err) {&#10;      console.error('SendGrid send failed. Full error object:');&#10;      // Log as much as is safe for debugging (but do not print the API key)&#10;      if (err.response &amp;&amp; err.response.body) {&#10;        console.error(JSON.stringify(err.response.body, null, 2));&#10;      } else {&#10;        console.error(err);&#10;      }&#10;      process.exitCode = 1;&#10;    }&#10;  })();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db.js" />
              <option name="updatedContent" value="const mongoose = require(&quot;mongoose&quot;);&#10;&#10;async function connectDB() {&#10;  try {&#10;    await mongoose.connect(&#10;      &quot;mongodb+srv://admin:4kTVlrRaaTthqvgW@bookstore.5ku2c2q.mongodb.net/bookstore?retryWrites=true&amp;w=majority&quot;,&#10;      {&#10;        useNewUrlParser: true,&#10;        useUnifiedTopology: true,&#10;      }&#10;    );&#10;&#10;    console.log(&quot;MongoDB connected!&quot;);&#10;  } catch (error) {&#10;    console.error(&quot;MongoDB connection error:&quot;, error);&#10;  }&#10;}&#10;&#10;module.exports = connectDB;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/models/Book.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/models/Book.js" />
              <option name="updatedContent" value="const mongoose = require(&quot;mongoose&quot;);&#10;&#10;const bookSchema = new mongoose.Schema({&#10;  title: String,&#10;  price: Number,&#10;});&#10;&#10;module.exports = mongoose.model(&quot;Book&quot;, bookSchema);&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;ktqt-server&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;Minimal Node.js server for the KTQT book app&quot;,&#10;  &quot;main&quot;: &quot;server.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;node server.js&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;express&quot;: &quot;^4.18.2&quot;,&#10;    &quot;mongoose&quot;: &quot;^7.6.1&quot;&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server.js" />
              <option name="updatedContent" value="const express = require(&quot;express&quot;);&#10;const connectDB = require(&quot;./db&quot;);&#10;const Book = require(&quot;./models/Book&quot;);&#10;&#10;const app = express();&#10;app.use(express.json());&#10;&#10;// Connect to MongoDB&#10;connectDB();&#10;&#10;// Test add data&#10;app.get(&quot;/test&quot;, async (req, res) =&gt; {&#10;  try {&#10;    const book = await Book.create({&#10;      title: &quot;Sách MongoDB của bé iu&quot;,&#10;      price: 99&#10;    });&#10;    res.json(book);&#10;  } catch (error) {&#10;    console.error(&quot;/test error:&quot;, error);&#10;    res.status(500).json({ error: error.message });&#10;  }&#10;});&#10;&#10;const PORT = process.env.PORT || 3000;&#10;app.listen(PORT, () =&gt; console.log(`Server running on port ${PORT}`));&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>